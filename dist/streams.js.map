{"version":3,"sources":["webpack:///dist/streams.js","webpack:///webpack/bootstrap b0bcf7c2f8a9eba2e738","webpack:///./index.js","webpack:///./src/module.js","webpack:///./src/writeable_stream.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","root","factory","Stream","this","interfaces","writeable","WriteableStream","options","writeCallback","flush","Buffer","state","hasCapacity","announce","cork","corked","uncork","getBuffer","length","write","obj","push","setTimeout","highWaterMark","WriteableState","let","defaults","objectMode","params","assign","isCorked","val","_writableState","data","console","log","cb"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,QAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,QAAAQ,IACAG,OAAAC,eAAAZ,QAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,KDMM,SAAUtB,EAAQD,QAASH,IEjEhC,SAAS2B,EAAMC,GACQ,gBAAXxB,IAAuBA,EAAOD,QAIvCC,EAAOD,QAAUyB,IAGjBD,EAAKE,OAASD,KAEhBE,KAAM,WACN,OACEC,WAAY/B,EAAQ,OF4ElB,SAAUI,EAAQD,QAASH,GG1FjCI,EAAOD,SACL6B,UAAWhC,EAAQ,KHkGf,SAAUI,EAAQD,SI7FxB,QAAS8B,GAAgBC,EAASC,GAgBhC,QAASC,KACPD,EAAcE,GACTC,EAAMC,cACTC,EAAS,SACTF,EAAMC,aAAc,GAEtBF,KAGF,QAASI,KACPH,EAAMI,QAAS,EAGjB,QAASC,KACHL,EAAMI,QAAUJ,EAAMM,YAAYC,OAAS,IAC7CT,IACAI,EAAS,UAEXF,EAAMI,QAAS,EAGjB,QAASI,GAAMC,GASb,MALAV,GAAOW,KAAKD,GACPT,EAAMI,QACTO,WAAWb,GAEbE,EAAMC,YAAcF,EAAOQ,QAAUP,EAAMY,cACpCZ,EAAMC,YAGf,QAASY,GAAejB,GACtBkB,GAAIC,IACFC,YAAY,EACZJ,cAAe,KAEbK,EAASzC,OAAO0C,OAAOH,EAAUnB,GAEjCuB,GAAW,EACXlB,GAAc,CAClB,QACEG,aACE,MAAOe,IAETf,WAAWgB,GACLA,IAAoB,IAAbD,IACTA,GAAW,GAERC,IACHD,GAAW,IAGfP,oBACE,MAAOK,GAAOL,eAEhBX,kBACE,MAAOA,IAETA,gBAAgBmB,GACVA,IAAuB,IAAhBnB,IACTA,GAAc,GAEXmB,IACHnB,GAAc,IAGlBK,UAAW,WACT,MAAOP,KAnFbe,GAAIf,MACAC,EAAQ,GAAIa,GAAejB,EAE/B,QACEY,MAAOA,EACPE,KAAMF,EAENL,KAAMA,EACNE,OAAQA,EAGRgB,eAAgBrB,GA8EpB,QAASE,GAAS7B,EAAMiD,GACtBC,QAAQC,IAAI,aAAcnD,GAhG5BP,EAAOD,QAAU,SAAS+B,EAAS6B,GACjC,MAAO,IAAI9B,GAAgBC,EAAS6B","file":"./dist/streams.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function(root, factory) {\n  if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Stream = factory();\n  }\n}(this, function() {\n  return {\n    interfaces: __webpack_require__(1)\n  };\n}));\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  writeable: __webpack_require__(2)\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n// reimplement some features of node steams for the browser\n\nmodule.exports = function(options, cb) {\n  return new WriteableStream(options, cb);\n}\n\nfunction WriteableStream(options, writeCallback) {\n  // The amount of data potentially buffered depends on the highWaterMark option passed into the streams constructor. For normal streams, the highWaterMark option specifies a total number of bytes.For streams operating in object mode, the highWaterMark specifies a total number of objects.\n  var Buffer = [];\n  var state = new WriteableState(options);\n\n  return {\n    write: write,\n    push: write,\n    // read\n    cork: cork,\n    uncork: uncork,\n    // end\n    // destroy\n    _writableState: state\n  }\n\n  function flush() {\n    writeCallback(Buffer);\n    if (!state.hasCapacity) {\n      announce('drain');\n      state.hasCapacity = true;\n    }\n    Buffer = [];\n  }\n\n  function cork() {\n    state.corked = true;\n  }\n\n  function uncork() {\n    if (state.corked && state.getBuffer().length > 0) {\n      flush();\n      announce('drain');\n    }\n    state.corked = false;\n  }\n\n  function write(obj) {\n    // Data is buffered in Readable streams when the implementation calls stream.push(chunk).If the consumer of the Stream does not call stream.read(), the data will sit in the internal queue until it is consumed.\n\n    // Data is buffered in Writable streams when the writable.write(chunk) method is called repeatedly. While the total size of the internal write buffer is below the threshold set by highWaterMark, calls to writable.write() will return true.Once the size of the internal buffer reaches or exceeds the highWaterMark, false will be returned.\n    Buffer.push(obj);\n    if (!state.corked) {\n      setTimeout(flush)\n    }\n    state.hasCapacity = Buffer.length <= state.highWaterMark;\n    return state.hasCapacity;\n  }\n\n  function WriteableState(options) {\n    var defaults = {\n      objectMode: true, // always true. Changes will be ignored\n      highWaterMark: 100 // objects to buffer\n    }\n    var params = Object.assign(defaults, options);\n\n    var isCorked = false;\n    var hasCapacity = true;\n    return {\n      get corked() {\n        return isCorked;\n      },\n      set corked(val) {\n        if (val && isCorked === false) {\n          isCorked = true;\n        }\n        if (!val) {\n          isCorked = false;\n        }\n      },\n      get highWaterMark() {\n        return params.highWaterMark;\n      },\n      get hasCapacity() {\n        return hasCapacity;\n      },\n      set hasCapacity(val) {\n        if (val && hasCapacity === false) {\n          hasCapacity = true;\n        }\n        if (!val) {\n          hasCapacity = false;\n        }\n      },\n      getBuffer: function () {\n        return Buffer;\n      }\n    }\n  }\n}\n\nfunction announce(name, data) {\n  console.log('announce: ', name);\n  // let event = new CustomEvent(name, {\n  //   detail: data\n  // });\n  // document.dispatchEvent(event);\n}\n\n// events:\n//   close\n//   drain\n//   error\n//   finish\n//   pipe\n//   unpipe\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/streams.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b0bcf7c2f8a9eba2e738","\n// if the module has no dependencies, the above pattern can be simplified to\n(function(root, factory) {\n  if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Stream = factory();\n  }\n}(this, function() {\n  return {\n    interfaces: require('./src/module.js')\n  };\n}));\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","module.exports = {\n  writeable: require('./writeable_stream')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/module.js","// reimplement some features of node steams for the browser\n\nmodule.exports = function(options, cb) {\n  return new WriteableStream(options, cb);\n}\n\nfunction WriteableStream(options, writeCallback) {\n  // The amount of data potentially buffered depends on the highWaterMark option passed into the streams constructor. For normal streams, the highWaterMark option specifies a total number of bytes.For streams operating in object mode, the highWaterMark specifies a total number of objects.\n  let Buffer = [];\n  let state = new WriteableState(options);\n\n  return {\n    write: write,\n    push: write,\n    // read\n    cork: cork,\n    uncork: uncork,\n    // end\n    // destroy\n    _writableState: state\n  }\n\n  function flush() {\n    writeCallback(Buffer);\n    if (!state.hasCapacity) {\n      announce('drain');\n      state.hasCapacity = true;\n    }\n    Buffer = [];\n  }\n\n  function cork() {\n    state.corked = true;\n  }\n\n  function uncork() {\n    if (state.corked && state.getBuffer().length > 0) {\n      flush();\n      announce('drain');\n    }\n    state.corked = false;\n  }\n\n  function write(obj) {\n    // Data is buffered in Readable streams when the implementation calls stream.push(chunk).If the consumer of the Stream does not call stream.read(), the data will sit in the internal queue until it is consumed.\n\n    // Data is buffered in Writable streams when the writable.write(chunk) method is called repeatedly. While the total size of the internal write buffer is below the threshold set by highWaterMark, calls to writable.write() will return true.Once the size of the internal buffer reaches or exceeds the highWaterMark, false will be returned.\n    Buffer.push(obj);\n    if (!state.corked) {\n      setTimeout(flush)\n    }\n    state.hasCapacity = Buffer.length <= state.highWaterMark;\n    return state.hasCapacity;\n  }\n\n  function WriteableState(options) {\n    let defaults = {\n      objectMode: true, // always true. Changes will be ignored\n      highWaterMark: 100 // objects to buffer\n    }\n    let params = Object.assign(defaults, options);\n\n    let isCorked = false;\n    let hasCapacity = true;\n    return {\n      get corked() {\n        return isCorked;\n      },\n      set corked(val) {\n        if (val && isCorked === false) {\n          isCorked = true;\n        }\n        if (!val) {\n          isCorked = false;\n        }\n      },\n      get highWaterMark() {\n        return params.highWaterMark;\n      },\n      get hasCapacity() {\n        return hasCapacity;\n      },\n      set hasCapacity(val) {\n        if (val && hasCapacity === false) {\n          hasCapacity = true;\n        }\n        if (!val) {\n          hasCapacity = false;\n        }\n      },\n      getBuffer: () => {\n        return Buffer;\n      }\n    }\n  }\n}\n\nfunction announce(name, data) {\n  console.log('announce: ', name);\n  // let event = new CustomEvent(name, {\n  //   detail: data\n  // });\n  // document.dispatchEvent(event);\n}\n\n// events:\n//   close\n//   drain\n//   error\n//   finish\n//   pipe\n//   unpipe\n\n\n\n// WEBPACK FOOTER //\n// ./src/writeable_stream.js"],"sourceRoot":""}